"""Test execution format to get blobs from the execution client."""

from hashlib import sha256
from typing import ClassVar, Dict, List

from pytest import FixtureRequest

from execution_testing.base_types import Address, Hash
from execution_testing.base_types.base_types import Bytes
from execution_testing.forks import Fork
from execution_testing.logging import (
    get_logger,
)
from execution_testing.rpc import (
    BlobAndProofV1,
    BlobAndProofV2,
    EngineRPC,
    EthRPC,
)
from execution_testing.rpc.rpc_types import GetBlobsResponse
from execution_testing.test_types import (
    NetworkWrappedTransaction,
    Transaction,
)
from execution_testing.test_types.transaction_types import (
    TransactionTestMetadata,
)

from .base import BaseExecute

logger = get_logger(__name__)


def versioned_hashes_with_blobs_and_proofs(
    tx: NetworkWrappedTransaction,
) -> Dict[Hash, BlobAndProofV1 | BlobAndProofV2]:
    """
    Return a dictionary of versioned hashes with their corresponding blobs and
    proofs.
    """
    versioned_hashes: Dict[Hash, BlobAndProofV1 | BlobAndProofV2] = {}
    for blob in tx.blob_objects:
        if isinstance(blob.proof, Bytes):
            versioned_hashes[blob.versioned_hash] = BlobAndProofV1(
                blob=blob.data, proof=blob.proof
            )
        elif isinstance(blob.proof, list):
            versioned_hashes[blob.versioned_hash] = BlobAndProofV2(
                blob=blob.data, proofs=blob.proof
            )
        else:
            raise ValueError(
                f"Blob with versioned hash {blob.versioned_hash.hex()} requires a proof "
                "that is not None"
            )

    return versioned_hashes


class BlobTransaction(BaseExecute):
    """
    Represents a test execution format to send blob transactions to the client
    and then use `engine_getBlobsV*` end points to validate the proofs
    generated by the execution client.
    """

    format_name: ClassVar[str] = "blob_transaction_test"
    description: ClassVar[str] = (
        "Send blob transactions to the execution client and validate their availability via "
        "`engine_getBlobsV*`"
    )

    txs: List[NetworkWrappedTransaction | Transaction]
    nonexisting_blob_hashes: List[Hash] | None = None

    def get_required_sender_balances(
        self,
        *,
        gas_price: int,
        max_fee_per_gas: int,
        max_priority_fee_per_gas: int,
        max_fee_per_blob_gas: int,
        fork: Fork,
    ) -> Dict[Address, int]:
        """Get the required sender balances."""
        balances: Dict[Address, int] = {}
        for tx in self.txs:
            sender = tx.sender
            assert sender is not None, "Sender is None"
            tx.set_gas_price(
                gas_price=gas_price,
                max_fee_per_gas=max_fee_per_gas,
                max_priority_fee_per_gas=max_priority_fee_per_gas,
                max_fee_per_blob_gas=max_fee_per_blob_gas,
            )
            if sender not in balances:
                balances[sender] = 0
            balances[sender] += tx.signer_minimum_balance(fork=fork)
        return balances

    def execute(
        self,
        fork: Fork,
        eth_rpc: EthRPC,
        engine_rpc: EngineRPC | None,
        request: FixtureRequest,
    ) -> None:
        """Execute the format."""
        versioned_hashes: Dict[Hash, BlobAndProofV1 | BlobAndProofV2] = {}
        sent_txs: List[Transaction] = []
        for tx_index, tx in enumerate(self.txs):
            tx = tx.with_signature_and_sender()
            expected_hash = tx.hash
            to_address = tx.to
            if isinstance(tx, NetworkWrappedTransaction):
                sent_txs.append(tx.tx)
                versioned_hashes.update(
                    versioned_hashes_with_blobs_and_proofs(tx)
                )
            else:
                sent_txs.append(tx)
            label = (
                to_address.label if isinstance(to_address, Address) else None
            )
            metadata = TransactionTestMetadata(
                test_id=request.node.nodeid,
                phase="testing",
                target=label,
                tx_index=tx_index,
            )
            received_hash = eth_rpc.send_raw_transaction(
                tx.rlp(), request_id=metadata.to_json()
            )
            assert expected_hash == received_hash, (
                f"Expected hash {expected_hash} does not match received hash {received_hash}."
            )

        if engine_rpc is None:
            logger.info(
                "Engine RPC is not available, skipping getBlobsV* validation."
            )
            return

        version = fork.engine_get_blobs_version()
        assert version is not None, (
            "Engine get blobs version is not supported by the fork."
        )

        # ensure that clients respond 'null' when they have no access to at
        # least one blob
        list_versioned_hashes = list(versioned_hashes.keys())
        if self.nonexisting_blob_hashes is not None:
            list_versioned_hashes.extend(self.nonexisting_blob_hashes)

        blob_response: GetBlobsResponse | None = engine_rpc.get_blobs(
            list_versioned_hashes, version=version
        )

        # if non-existing blob hashes were request then the response must be
        # 'null'
        if self.nonexisting_blob_hashes is not None:
            if blob_response is not None:
                raise ValueError(
                    f"Non-existing blob hashes were requested and "
                    "the client was expected to respond with 'null', but instead it replied: "
                    f"{blob_response.root}"
                )
            else:
                logger.info(
                    "Test was passed (partial responses are not allowed and the client "
                    "correctly returned 'null')"
                )
                eth_rpc.wait_for_transactions(sent_txs)
                return

        assert blob_response is not None
        local_blobs_and_proofs = list(versioned_hashes.values())
        assert len(blob_response) == len(local_blobs_and_proofs), (
            f"Expected {len(local_blobs_and_proofs)} blobs and proofs, got {len(blob_response)}."
        )

        for expected_blob, received_blob in zip(
            local_blobs_and_proofs, blob_response.root, strict=True
        ):
            if received_blob is None:
                raise ValueError("Received blob is empty.")
            if isinstance(expected_blob, BlobAndProofV1):
                if not isinstance(received_blob, BlobAndProofV1):
                    raise ValueError("Received blob is not a BlobAndProofV1.")
                if expected_blob.blob != received_blob.blob:
                    raise ValueError("Blob mismatch.")
                if expected_blob.proof != received_blob.proof:
                    raise ValueError("Proof mismatch.")
            elif isinstance(expected_blob, BlobAndProofV2):
                if not isinstance(received_blob, BlobAndProofV2):
                    raise ValueError("Received blob is not a BlobAndProofV2.")
                if expected_blob.blob != received_blob.blob:
                    raise ValueError("Blob mismatch.")
                if expected_blob.proofs != received_blob.proofs:
                    error_message = "Proofs mismatch."
                    error_message += f"len(expected_blob.proofs) = {len(expected_blob.proofs)}, "
                    error_message += f"len(received_blob.proofs) = {len(received_blob.proofs)}\n"
                    if len(expected_blob.proofs) == len(received_blob.proofs):
                        index = 0

                        for expected_proof, received_proof in zip(
                            expected_blob.proofs,
                            received_blob.proofs,
                            strict=False,
                        ):
                            if len(expected_proof) != len(received_proof):
                                error_message += (
                                    f"Proof length mismatch. index = {index},"
                                )
                                error_message += f"expected_proof length = {len(expected_proof)}, "
                                error_message += f"received_proof length = {len(received_proof)}\n"
                                index += 1
                                continue
                            if expected_proof != received_proof:
                                error_message += (
                                    f"Proof mismatch. index = {index},"
                                )
                                error_message += f"expected_proof hash = {sha256(expected_proof).hexdigest()}, "
                                error_message += f"received_proof hash = {sha256(received_proof).hexdigest()}\n"
                            index += 1
                    raise ValueError(error_message)
            else:
                raise ValueError(
                    f"Unexpected blob type: {type(expected_blob)}"
                )

        eth_rpc.wait_for_transactions(sent_txs)
